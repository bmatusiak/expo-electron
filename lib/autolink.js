const fs = require('fs');
const path = require('path');

function walkPackages(dir, cb) {
    if (!fs.existsSync(dir)) return;
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const ent of entries) {
        const name = ent.name;
        const full = path.join(dir, name);
        // follow symlinks: ensure the entry resolves to a directory
        try {
            const st = fs.statSync(full);
            if (!st.isDirectory()) continue;
        } catch (e) {
            continue;
        }
        const pkgJson = path.join(full, 'package.json');
        if (fs.existsSync(pkgJson)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(pkgJson, 'utf8'));
                cb({ name: pkg.name || name, root: full, pkg });
            } catch (e) { /* ignore */ }
        }
        const nested = path.join(full, 'node_modules');
        if (fs.existsSync(nested)) walkPackages(nested, cb);
    }
}

function findElectronEntries(projectRoot) {
    // Follow React Native's approach: only consider the project's top-level
    // dependencies and devDependencies. This prevents autolinking nested
    // transitive packages. For each declared dependency, check whether the
    // package exists under node_modules and contains an `electron/` folder.
    const pkgPath = path.join(projectRoot, 'package.json');
    const results = [];
    let projectPkg = {};
    try {
        if (fs.existsSync(pkgPath)) projectPkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
    } catch (e) {
        console.warn('Autolink: failed to read project package.json', e && e.message);
        return results;
    }

    const deps = Object.assign({}, projectPkg.dependencies || {}, projectPkg.devDependencies || {});
    const names = Object.keys(deps || {});
    for (const name of names) {
        // Resolve the package directly under projectRoot/node_modules
        const modRoot = path.join(projectRoot, 'node_modules', name);
        try {
            const st = fs.statSync(modRoot);
            if (!st.isDirectory()) continue;
        } catch (e) {
            // not installed at top-level; skip
            continue;
        }
        const electronDir = path.join(modRoot, 'electron');
        const electronIndex = path.join(electronDir, 'index.js');
        // Only link if the package exposes an `electron/index.js` entry.
        if (!fs.existsSync(electronDir) || !fs.existsSync(electronIndex)) continue;
        // Read package.json for convenience (not used to gate linking)
        let pkg = {};
        try {
            const pjson = path.join(modRoot, 'package.json');
            if (fs.existsSync(pjson)) pkg = JSON.parse(fs.readFileSync(pjson, 'utf8'));
        } catch (e) { /* ignore malformed package.json */ }
        results.push({ name, root: modRoot, pkg, entry: 'electron' });
    }
    return results;
}

function makePreload(mods, outPath, projectRoot) {
    const lines = [];
    lines.push('// GENERATED by expo-electron autolink â€” do not edit by hand');
    lines.push("const path = require('path');");
    lines.push("const { contextBridge } = require('electron');");
    lines.push('const ElectronNative = {};');
    lines.push("function _safeRequire(p) { try { return require(p); } catch (e) { return null } }");

    for (const m of mods) {
        lines.push(`// module: ${m.name}`);
        lines.push(`(function(){`);
        if (m.expoBlock && m.expoBlock.entry) {
            lines.push(`  const devPath = (() => { try { return require.resolve('${m.name}/${m.expoBlock.entry}'); } catch(e) { return null } })();`);
        } else {
            lines.push(`  const devPath = (() => { try { return require.resolve('${m.name}/electron'); } catch(e) { try { return require.resolve('${m.name}'); } catch(e2){ return null } } })();`);
        }
        lines.push(`  // prefer unpacked native assets when running packaged (app.asar.unpacked)
  const _resBase = (process.resourcesPath || process.cwd());`);

        // collect .node files present under the package so we can prefer
        // requiring the native addon binary directly in production
        const nodeFiles = [];
        try {
            function walkForNode(dir) {
                if (!fs.existsSync(dir)) return;
                for (const e of fs.readdirSync(dir)) {
                    const full = path.join(dir, e);
                    try {
                        const st = fs.statSync(full);
                        if (st.isDirectory()) walkForNode(full);
                        else if (st.isFile() && path.extname(full).toLowerCase() === '.node') nodeFiles.push(full);
                    } catch (e) { }
                }
            }
            walkForNode(m.root);
        } catch (e) { }

        // If .node files exist, prefer them (they are unpacked via asarUnpack).
        if (nodeFiles.length > 0) {
            const candExpr = nodeFiles.map((f) => {
                const under = path.relative(m.root, f).replace(/\\/g, '/');
                // will produce: path.join(_resBase, 'app.asar.unpacked', 'native', '<mod>', '<under>')
                return `path.join(_resBase, 'app.asar.unpacked', 'native', '${m.name}', '${under.replace(/'/g, "\\'")}')`;
            }).join(', ');
            lines.push(`  const prodPath = (() => {\n    const fs = require('fs');\n    const candidates = [${candExpr}];\n    for (const c of candidates) { try { if (fs.existsSync(c)) return c; } catch(e) {} }\n    // also check the non-unpacked native/ extraResource location for back-compat\n    for (const c of candidates) { try { const alt = c.replace('app.asar.unpacked' , ''); if (fs.existsSync(alt)) return alt; } catch(e) {} }\n    // fallback: packaged JS inside app.asar (if present)\n    try { const a = path.join(_resBase, 'app.asar', 'native', '${m.name}', '${path.basename(m.pkg && m.pkg.main ? m.pkg.main : 'index.js')}'); if (fs.existsSync(a)) return a; } catch(e) {}\n    return null;\n  })();`);
        } else if (m.expoBlock && m.expoBlock.entry) {
            const base = path.basename(m.expoBlock.entry);
            lines.push(`  const prodPath = (() => {\n    try { const a = path.join(_resBase, 'app.asar', 'native', '${m.name}', '${base}'); if (require('fs').existsSync(a)) return a; } catch(e) {}\n    try { const r = path.join(_resBase, 'native', '${m.name}', '${base}'); if (require('fs').existsSync(r)) return r; } catch(e) {}\n    try { const u = path.join(_resBase, 'app.asar.unpacked', 'native', '${m.name}', '${base}'); if (require('fs').existsSync(u)) return u; } catch(e) {}\n    return null;\n  })();`);
        } else if (m.entry === 'electron') {
            lines.push(`  const prodPath = (() => {\n    try { const a = path.join(_resBase, 'app.asar', 'native', '${m.name}', 'index.js'); if (require('fs').existsSync(a)) return a; } catch(e) {}\n    try { const r = path.join(_resBase, 'native', '${m.name}', 'index.js'); if (require('fs').existsSync(r)) return r; } catch(e) {}\n    try { const u = path.join(_resBase, 'app.asar.unpacked', 'native', '${m.name}', 'index.js'); if (require('fs').existsSync(u)) return u; } catch(e) {}\n    return null;\n  })();`);
        } else {
            lines.push(`  const prodPath = null;`);
        }
        lines.push(`  let impl = null;`);
        lines.push(`  if (devPath) impl = _safeRequire(devPath);`);
        lines.push(`  if (!impl && prodPath) impl = _safeRequire(prodPath);`);
        lines.push(`  if (impl) ElectronNative['${m.name}'] = impl; else ElectronNative['${m.name}'] = { _missing: true };`);
        lines.push(`})();`);
    }

    lines.push("contextBridge.exposeInMainWorld('ElectronNative', ElectronNative);");
    fs.mkdirSync(path.dirname(outPath), { recursive: true });
    fs.writeFileSync(outPath, lines.join('\n'), 'utf8');
}

function makeResources(mods, projectRoot) {
    const resources = [];
    for (const m of mods) {
        const electronRoot = path.join(m.root, 'electron');
        if (fs.existsSync(electronRoot)) {
            // Only copy native binary artifacts (.node) into the packaging
            // workspace. JS wrappers are expected to be bundled into app.asar.
            function collectNodeFiles(dir, out) {
                if (!fs.existsSync(dir)) return;
                for (const ent of fs.readdirSync(dir)) {
                    const full = path.join(dir, ent);
                    try {
                        const st = fs.statSync(full);
                        if (st.isDirectory()) collectNodeFiles(full, out);
                        else if (st.isFile() && path.extname(full).toLowerCase() === '.node') out.push(full);
                    } catch (e) { }
                }
            }
            const nodes = [];
            collectNodeFiles(m.root, nodes);
            for (const f of nodes) {
                const relFrom = path.relative(projectRoot, f).replace(/\\/g, '/');
                const relUnderModule = path.relative(m.root, f).replace(/\\/g, '/');
                const dest = `native/${m.name}/${relUnderModule}`;
                resources.push({ from: relFrom, to: dest });
            }
            continue;
        }
        if (m.expoBlock && m.expoBlock.entry) {
            const src = path.join(m.root, m.expoBlock.entry);
            if (fs.existsSync(src)) {
                let rel = path.relative(projectRoot, src).replace(/\\/g, '/');
                if (!rel) rel = '.';
                resources.push({ from: rel, to: `native/${m.name}/${path.basename(m.expoBlock.entry)}` });
            }
        }
    }
    return resources;
}

function run(projectRoot, targetDir) {
    try {
        const mods = findElectronEntries(projectRoot);
        if (!mods || mods.length === 0) {
            console.log('Autolink: no electron modules found to link');
        } else {
            for (const m of mods) {
                console.log(`Autolink: linking ${m.name} -> ${m.root}`);
            }
        }
        // If a targetDir is supplied (prebuild folder), write into its main/ folder
        const outPreload = targetDir ? path.join(targetDir, 'main', 'preload.js') : path.join(projectRoot, 'src', 'preload.js');
        makePreload(mods, outPreload, projectRoot);
        const resources = makeResources(mods, projectRoot);
        const outResources = targetDir ? path.join(targetDir, 'electron-resources.json') : path.join(projectRoot, 'electron-resources.json');
        fs.writeFileSync(outResources, JSON.stringify(resources, null, 2), 'utf8');
        console.log('expo-electron autolink: wrote', outPreload, 'and', outResources);
    } catch (e) {
        console.error('expo-electron autolink: failed', e && e.message);
    }
}

module.exports = { run };
