const fs = require('fs');
const path = require('path');

function walkPackages(dir, cb) {
    if (!fs.existsSync(dir)) return;
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const ent of entries) {
        const name = ent.name;
        const full = path.join(dir, name);
        // follow symlinks: ensure the entry resolves to a directory
        try {
            const st = fs.statSync(full);
            if (!st.isDirectory()) continue;
        } catch (e) {
            continue;
        }
        const pkgJson = path.join(full, 'package.json');
        if (fs.existsSync(pkgJson)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(pkgJson, 'utf8'));
                cb({ name: pkg.name || name, root: full, pkg });
            } catch (e) { /* ignore */ }
        }
        const nested = path.join(full, 'node_modules');
        if (fs.existsSync(nested)) walkPackages(nested, cb);
    }
}

function findElectronEntries(projectRoot) {
    // Follow React Native's approach: only consider the project's top-level
    // dependencies and devDependencies. This prevents autolinking nested
    // transitive packages. For each declared dependency, check whether the
    // package exists under node_modules and contains an `electron/` folder.
    const pkgPath = path.join(projectRoot, 'package.json');
    const results = [];
    let projectPkg = {};
    try {
        if (fs.existsSync(pkgPath)) projectPkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
    } catch (e) {
        console.warn('Autolink: failed to read project package.json', e && e.message);
        return results;
    }

    const deps = Object.assign({}, projectPkg.dependencies || {}, projectPkg.devDependencies || {});
    const names = Object.keys(deps || {});
    for (const name of names) {
        // Resolve the package directly under projectRoot/node_modules
        const modRoot = path.join(projectRoot, 'node_modules', name);
        try {
            const st = fs.statSync(modRoot);
            if (!st.isDirectory()) continue;
        } catch (e) {
            // not installed at top-level; skip
            continue;
        }
        const electronDir = path.join(modRoot, 'electron');
        const electronIndex = path.join(electronDir, 'index.js');
        // Only link if the package exposes an `electron/index.js` entry.
        if (!fs.existsSync(electronDir) || !fs.existsSync(electronIndex)) continue;
        // Read package.json for convenience (not used to gate linking)
        let pkg = {};
        try {
            const pjson = path.join(modRoot, 'package.json');
            if (fs.existsSync(pjson)) pkg = JSON.parse(fs.readFileSync(pjson, 'utf8'));
        } catch (e) { /* ignore malformed package.json */ }
        results.push({ name, root: modRoot, pkg, entry: 'electron' });
    }
    return results;
}

function makePreload(mods, outPath, projectRoot) {
    const lines = [];
    lines.push('// GENERATED by expo-electron autolink â€” do not edit by hand');
    lines.push("const path = require('path');");
    lines.push("const { contextBridge, ipcRenderer } = require('electron');");
    lines.push('const ElectronNative = {};');
    lines.push("function _safeRequire(p) { try { return require(p); } catch (e) { return null } }");
    lines.push('');
    lines.push('// Safe, minimal bridge for renderer <-> main communication');
    lines.push("const __VALID_INVOKE_CHANNELS__ = [");
    lines.push("  'app:relaunch',");
    lines.push("  'dialog:open',");
    lines.push("  'dialog:save',");
    lines.push("  'clipboard:readText',");
    lines.push("  'clipboard:writeText',");
    lines.push("  'nativeTheme:get',");
    lines.push("  'nativeTheme:setThemeSource',");
    lines.push("  'shell:openExternal',");
    lines.push("  'shell:showItemInFolder',");
    lines.push("  'app:getPath',");
    lines.push("]; ");

    lines.push("contextBridge.exposeInMainWorld('electron', {");
    lines.push('  onDeepLink: (callback) => {');
    lines.push('    if (typeof callback !== \'function\') return () => {};');
    lines.push('    const subscription = (event, url) => callback(url);');
    lines.push("    ipcRenderer.on('on-deep-link', subscription);");
    lines.push('    return () => {');
    lines.push("      try { ipcRenderer.removeListener('on-deep-link', subscription); } catch (e) {}");
    lines.push('    };');
    lines.push('  },');
    lines.push('  onThemeChanged: (callback) => {');
    lines.push('    if (typeof callback !== \'function\') return () => {};');
    lines.push('    const subscription = (event, payload) => callback(payload);');
    lines.push("    ipcRenderer.on('electron-native-theme-updated', subscription);");
    lines.push('    return () => {');
    lines.push("      try { ipcRenderer.removeListener('electron-native-theme-updated', subscription); } catch (e) {}");
    lines.push('    };');
    lines.push('  },');
    lines.push('  onPowerEvent: (callback) => {');
    lines.push('    if (typeof callback !== \'function\') return () => {};');
    lines.push('    const subscription = (event, payload) => callback(payload);');
    lines.push("    ipcRenderer.on('electron-power-event', subscription);");
    lines.push('    return () => {');
    lines.push("      try { ipcRenderer.removeListener('electron-power-event', subscription); } catch (e) {}");
    lines.push('    };');
    lines.push('  },');
    lines.push('  getNativeModuleStatus: () => {');
    lines.push('    const status = {};');
    lines.push('    for (const k of Object.keys(ElectronNative)) {');
    lines.push('      const v = ElectronNative[k];');
    lines.push('      status[k] = !!(v && !v._missing);');
    lines.push('    }');
    lines.push('    return status;');
    lines.push('  },');
    lines.push('  invoke: (channel, data) => {');
    lines.push('    if (__VALID_INVOKE_CHANNELS__.includes(channel)) {');
    lines.push('      return ipcRenderer.invoke(channel, data);');
    lines.push('    }');
    lines.push('  },');
    // Convenience wrappers (must be defined in exposeInMainWorld; the
    // resulting API object is not reliably extensible from the page).
    lines.push("  openFileDialog: (options) => ipcRenderer.invoke('dialog:open', options),");
    lines.push("  saveFileDialog: (options) => ipcRenderer.invoke('dialog:save', options),");
    lines.push("  readClipboardText: () => ipcRenderer.invoke('clipboard:readText'),");
    lines.push("  writeClipboardText: (text) => ipcRenderer.invoke('clipboard:writeText', text),");
    lines.push("  getTheme: () => ipcRenderer.invoke('nativeTheme:get'),");
    lines.push("  setThemeSource: (themeSource) => ipcRenderer.invoke('nativeTheme:setThemeSource', themeSource),");
    lines.push("  openExternal: (url) => ipcRenderer.invoke('shell:openExternal', url),");
    lines.push("  showItemInFolder: (filePath) => ipcRenderer.invoke('shell:showItemInFolder', filePath),");
    lines.push("  getPath: (name) => ipcRenderer.invoke('app:getPath', name),");
    lines.push('});');

    function isUsefulNodeBinary(filePath) {
        const rel = String(filePath || '').replace(/\\/g, '/');
        if (!rel.toLowerCase().endsWith('.node')) return false;
        // node-gyp intermediates (Linux/macOS) we do not want to ship.
        if (rel.includes('/obj.target/')) return false;
        if (rel.includes('/obj/')) return false;
        return true;
    }

    for (const m of mods) {
        lines.push(`// module: ${m.name}`);
        lines.push(`(function(){`);
        if (m.expoBlock && m.expoBlock.entry) {
            lines.push(`  const devPath = (() => { try { return require.resolve('${m.name}/${m.expoBlock.entry}'); } catch(e) { return null } })();`);
        } else {
            lines.push(`  const devPath = (() => { try { return require.resolve('${m.name}/electron'); } catch(e) { try { return require.resolve('${m.name}'); } catch(e2){ return null } } })();`);
        }
        lines.push(`  // Prefer native assets shipped as extraResource under the app resources dir.
      const _resBase = (process.resourcesPath || process.cwd());`);

        // collect .node files present under the package so we can prefer
        // requiring the native addon binary directly in production
        const nodeFiles = [];
        try {
            function walkForNode(dir) {
                if (!fs.existsSync(dir)) return;
                for (const e of fs.readdirSync(dir)) {
                    const full = path.join(dir, e);
                    try {
                        const st = fs.statSync(full);
                        if (st.isDirectory()) walkForNode(full);
                        else if (st.isFile() && isUsefulNodeBinary(full)) nodeFiles.push(full);
                    } catch (e) { }
                }
            }
            walkForNode(m.root);
        } catch (e) { }

        // If .node files exist, prefer them (they must be real files on disk).
        if (nodeFiles.length > 0) {
            const candExpr = nodeFiles.map((f) => {
                const under = path.relative(m.root, f).replace(/\\/g, '/');
                // will produce: path.join(_resBase, 'native', '<mod>', '<under>')
                return `path.join(_resBase, 'native', '${m.name}', '${under.replace(/'/g, "\\'")}')`;
            }).join(', ');
            lines.push(`  const prodPath = (() => {\n    const fs = require('fs');\n    const candidates = [${candExpr}];\n    for (const c of candidates) { try { if (fs.existsSync(c)) return c; } catch(e) {} }\n    return null;\n  })();`);
        } else {
            // This tool is intentionally strict: production linking expects a native
            // addon binary (.node) that will be shipped as a standalone file under resources/native.
            // We do not load JS wrappers from resources in production.
            lines.push(`  const prodPath = null;`);
        }
        lines.push(`  let impl = null;`);
        lines.push(`  if (devPath) impl = _safeRequire(devPath);`);
        lines.push(`  if (!impl && prodPath) impl = _safeRequire(prodPath);`);
        lines.push(`  if (impl) ElectronNative['${m.name}'] = impl; else ElectronNative['${m.name}'] = { _missing: true };`);
        lines.push(`})();`);
    }

    lines.push("contextBridge.exposeInMainWorld('ElectronNative', ElectronNative);");
    fs.mkdirSync(path.dirname(outPath), { recursive: true });
    fs.writeFileSync(outPath, lines.join('\n'), 'utf8');
}

function makeResources(mods, projectRoot) {
    const resources = [];
    for (const m of mods) {
        const electronRoot = path.join(m.root, 'electron');
        if (fs.existsSync(electronRoot)) {
            // Only copy native binary artifacts (.node) into the packaging
            // workspace. JS wrappers are expected to be bundled into app.asar.
            function isUsefulNodeBinary(filePath) {
                const rel = String(filePath || '').replace(/\\/g, '/');
                if (!rel.toLowerCase().endsWith('.node')) return false;
                if (rel.includes('/obj.target/')) return false;
                if (rel.includes('/obj/')) return false;
                return true;
            }

            function collectNodeFiles(dir, out) {
                if (!fs.existsSync(dir)) return;
                for (const ent of fs.readdirSync(dir)) {
                    const full = path.join(dir, ent);
                    try {
                        const st = fs.statSync(full);
                        if (st.isDirectory()) collectNodeFiles(full, out);
                        else if (st.isFile() && isUsefulNodeBinary(full)) out.push(full);
                    } catch (e) { }
                }
            }
            const nodes = [];
            collectNodeFiles(m.root, nodes);
            for (const f of nodes) {
                const relFrom = path.relative(projectRoot, f).replace(/\\/g, '/');
                const relUnderModule = path.relative(m.root, f).replace(/\\/g, '/');
                const dest = `native/${m.name}/${relUnderModule}`;
                resources.push({ from: relFrom, to: dest });
            }
            continue;
        }
        if (m.expoBlock && m.expoBlock.entry) {
            const src = path.join(m.root, m.expoBlock.entry);
            if (fs.existsSync(src)) {
                let rel = path.relative(projectRoot, src).replace(/\\/g, '/');
                if (!rel) rel = '.';
                resources.push({ from: rel, to: `native/${m.name}/${path.basename(m.expoBlock.entry)}` });
            }
        }
    }
    return resources;
}

function run(projectRoot, targetDir) {
    try {
        const mods = findElectronEntries(projectRoot);
        if (!mods || mods.length === 0) {
            console.log('Autolink: no electron modules found to link');
        } else {
            for (const m of mods) {
                console.log(`Autolink: linking ${m.name} -> ${m.root}`);
            }
        }
        // If a targetDir is supplied (prebuild folder), write into its main/ folder
        const outPreload = targetDir ? path.join(targetDir, 'main', 'preload.js') : path.join(projectRoot, 'src', 'preload.js');
        makePreload(mods, outPreload, projectRoot);
        const resources = makeResources(mods, projectRoot);
        const outResources = targetDir ? path.join(targetDir, 'electron-resources.json') : path.join(projectRoot, 'electron-resources.json');
        fs.writeFileSync(outResources, JSON.stringify(resources, null, 2), 'utf8');
        console.log('expo-electron autolink: wrote', outPreload, 'and', outResources);
    } catch (e) {
        console.error('expo-electron autolink: failed', e && e.message);
    }
}

module.exports = { run };
