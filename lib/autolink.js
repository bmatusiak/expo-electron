const fs = require('fs');
const path = require('path');

function walkPackages(dir, cb) {
    if (!fs.existsSync(dir)) return;
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const ent of entries) {
        const name = ent.name;
        const full = path.join(dir, name);
        // follow symlinks: ensure the entry resolves to a directory
        try {
            const st = fs.statSync(full);
            if (!st.isDirectory()) continue;
        } catch (e) {
            continue;
        }
        const pkgJson = path.join(full, 'package.json');
        if (fs.existsSync(pkgJson)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(pkgJson, 'utf8'));
                cb({ name: pkg.name || name, root: full, pkg });
            } catch (e) { /* ignore */ }
        }
        const nested = path.join(full, 'node_modules');
        if (fs.existsSync(nested)) walkPackages(nested, cb);
    }
}

function findElectronEntries(projectRoot) {
    const nodeModules = path.join(projectRoot, 'node_modules');
    const results = [];
    walkPackages(nodeModules, ({ name, root, pkg }) => {
        const electronDir = path.join(root, 'electron');
        const hasElectronDir = fs.existsSync(electronDir);
        // Only autolink packages that provide an electron/ folder AND
        // list `expo-electron` as a dependency (deps/devDeps/peerDeps/optionalDeps).
        if (!hasElectronDir) return;
        const deps = pkg.dependencies || {};
        const dev = pkg.devDependencies || {};
        const peer = pkg.peerDependencies || {};
        const opt = pkg.optionalDependencies || {};
        const declares = !!(deps['expo-electron'] || dev['expo-electron'] || peer['expo-electron'] || opt['expo-electron']);
        if (!declares) {
            console.log(`Autolink: skipping ${name} — has electron/ but does not declare expo-electron dependency`);
            return;
        }
        results.push({ name, root, pkg, entry: 'electron' });
    });
    return results;
}

function makePreload(mods, outPath) {
    const lines = [];
    lines.push('// GENERATED by expo-electron autolink — do not edit by hand');
    lines.push("const path = require('path');");
    lines.push("const { contextBridge } = require('electron');");
    lines.push('const native = {};');
    lines.push("function _safeRequire(p) { try { return require(p); } catch (e) { return null } }");

    for (const m of mods) {
        lines.push(`// module: ${m.name}`);
        lines.push(`(function(){`);
        if (m.expoBlock && m.expoBlock.entry) {
            lines.push(`  const devPath = (() => { try { return require.resolve('${m.name}/${m.expoBlock.entry}'); } catch(e) { return null } })();`);
        } else {
            lines.push(`  const devPath = (() => { try { return require.resolve('${m.name}/electron'); } catch(e) { try { return require.resolve('${m.name}'); } catch(e2){ return null } } })();`);
        }
        lines.push(`  // prefer unpacked native assets when running packaged (app.asar.unpacked)
  const _resBase = (process.resourcesPath || process.cwd());`);
        if (m.expoBlock && m.expoBlock.entry) {
            const base = path.basename(m.expoBlock.entry);
            lines.push(`  const prodPath = (() => {\n    try { const u = path.join(_resBase, 'app.asar.unpacked', 'native', '${m.name}', '${base}'); if (require('fs').existsSync(u)) return u; } catch(e) {}\n    return path.join(_resBase, 'native', '${m.name}', '${base}');\n  })();`);
        } else if (m.entry === 'electron') {
            lines.push(`  const prodPath = (() => {\n    try { const u = path.join(_resBase, 'app.asar.unpacked', 'native', '${m.name}', 'index.js'); if (require('fs').existsSync(u)) return u; } catch(e) {}\n    return path.join(_resBase, 'native', '${m.name}', 'index.js');\n  })();`);
        } else {
            lines.push(`  const prodPath = null;`);
        }
        lines.push(`  let impl = null;`);
        lines.push(`  if (devPath) impl = _safeRequire(devPath);`);
        lines.push(`  if (!impl && prodPath) impl = _safeRequire(prodPath);`);
        lines.push(`  if (impl) native['${m.name}'] = impl; else native['${m.name}'] = { _missing: true };`);
        lines.push(`})();`);
    }

    lines.push("contextBridge.exposeInMainWorld('native', native);");
    fs.mkdirSync(path.dirname(outPath), { recursive: true });
    fs.writeFileSync(outPath, lines.join('\n'), 'utf8');
}

function makeResources(mods, projectRoot) {
    const resources = [];
    for (const m of mods) {
        const electronRoot = path.join(m.root, 'electron');
        if (fs.existsSync(electronRoot)) {
            // preserve the `electron/` subfolder when copying into the
            // packaging workspace so relative requires (e.g. `../index.js`)
            // inside the electron entry continue to resolve correctly.
            let relElectron = path.relative(projectRoot, electronRoot).replace(/\\/g, '/');
            if (!relElectron) relElectron = '.';
            resources.push({ from: relElectron, to: `native/${m.name}/electron` });
            // Also copy the package's main entry (pkg.main or index.js)
            // into the native package root so `require('../index.js')` from
            // electron code will resolve to that file.
            try {
                const mainEntry = (m.pkg && (m.pkg.main || 'index.js')) || 'index.js';
                const mainSrc = path.join(m.root, mainEntry);
                if (fs.existsSync(mainSrc)) {
                    let relMain = path.relative(projectRoot, mainSrc).replace(/\\/g, '/');
                    if (!relMain) relMain = '.';
                    resources.push({ from: relMain, to: `native/${m.name}/${path.basename(mainEntry)}` });
                }
            } catch (e) {
                // ignore
            }
            // also include compiled addon outputs if present under build/Release or build/Debug
            const buildRelease = path.join(m.root, 'build', 'Release');
            const buildDebug = path.join(m.root, 'build', 'Debug');
            if (fs.existsSync(buildRelease)) {
                let relb = path.relative(projectRoot, buildRelease).replace(/\\/g, '/');
                resources.push({ from: relb, to: `native/${m.name}/build/Release` });
            }
            if (fs.existsSync(buildDebug)) {
                let relb = path.relative(projectRoot, buildDebug).replace(/\\/g, '/');
                resources.push({ from: relb, to: `native/${m.name}/build/Debug` });
            }
            continue;
        }
        if (m.expoBlock && m.expoBlock.entry) {
            const src = path.join(m.root, m.expoBlock.entry);
            if (fs.existsSync(src)) {
                let rel = path.relative(projectRoot, src).replace(/\\/g, '/');
                if (!rel) rel = '.';
                resources.push({ from: rel, to: `native/${m.name}/${path.basename(m.expoBlock.entry)}` });
            }
        }
    }
    return resources;
}

function run(projectRoot, targetDir) {
    try {
        const mods = findElectronEntries(projectRoot);
        if (!mods || mods.length === 0) {
            console.log('Autolink: no electron modules found to link');
        } else {
            for (const m of mods) {
                console.log(`Autolink: linking ${m.name} -> ${m.root}`);
            }
        }
        // If a targetDir is supplied (prebuild folder), write into its main/ folder
        const outPreload = targetDir ? path.join(targetDir, 'main', 'preload.js') : path.join(projectRoot, 'src', 'preload.js');
        makePreload(mods, outPreload);
        const resources = makeResources(mods, projectRoot);
        const outResources = targetDir ? path.join(targetDir, 'electron-resources.json') : path.join(projectRoot, 'electron-resources.json');
        fs.writeFileSync(outResources, JSON.stringify(resources, null, 2), 'utf8');
        console.log('expo-electron autolink: wrote', outPreload, 'and', outResources);
    } catch (e) {
        console.error('expo-electron autolink: failed', e && e.message);
    }
}

module.exports = { run };
